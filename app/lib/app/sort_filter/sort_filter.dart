import 'package:black_hole_flutter/black_hole_flutter.dart';
import 'package:dartx/dartx.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:schulcloud/app/module.dart';

import '../utils.dart';
import 'filtering.dart';
import 'sorting.dart';

typedef DataChangeCallback<D> = void Function(D newData);
typedef SortFilterChangeCallback<T> = void Function(
    SortFilterSelection<T> newSortFilter);

@immutable
class SortFilter<T> {
  SortFilter({
    this.sorters = const {},
    @required this.defaultSorter,
    this.defaultSortOrder = SortOrder.ascending,
    this.filters = const {},
  })  : assert(sorters != null),
        assert(sorters.isNotEmpty),
        assert(defaultSorter != null),
        assert(defaultSortOrder != null),
        assert(filters != null);

  final Map<String, Sorter<T>> sorters;
  final String defaultSorter;
  final SortOrder defaultSortOrder;
  final Map<String, Filter<T, dynamic>> filters;

  SortFilterSelection<T> get defaultSelection {
    return SortFilterSelection(
      config: this,
      sortSelectionKey: defaultSorter,
      sortOrder: defaultSortOrder,
      filterSelections: {
        for (final entry in filters.entries)
          entry.key: entry.value.defaultSelection,
      },
    );
  }

  /// Parses a query string generated by the web client, e.g.
  /// https://hpi-schul-cloud.de/homework/#?dueDateFrom=2020-03-09&dueDateTo=2020-03-27&private=true&publicSubmissions=false&sort=updatedAt&sortorder=1&teamSubmissions=true
  SortFilterSelection<T> tryParseWebQuery(Map<String, String> query) {
    if (query.isEmpty) {
      return defaultSelection;
    }

    return SortFilterSelection(
      config: this,
      sortSelectionKey: _tryParseWebQuerySorter(query) ?? defaultSorter,
      sortOrder: SortOrderUtils.tryParseWebQuery(query) ?? defaultSortOrder,
      filterSelections: {
        for (final entry in filters.entries)
          entry.key: entry.value.tryParseWebQuery(query, entry.key),
      },
    );
  }

  String _tryParseWebQuerySorter(Map<String, String> query) {
    final key = query['sort'];
    return sorters.entries
        .firstOrNullWhere(
            (option) => key == (option.value.webQueryKey ?? option.key))
        ?.key;
  }
}

@immutable
class SortFilterSelection<T> {
  SortFilterSelection({
    @required this.config,
    @required this.sortSelectionKey,
    this.sortOrder = SortOrder.ascending,
    Map<String, dynamic> filterSelections = const {},
  })  : assert(config != null),
        assert(sortSelectionKey != null),
        assert(sortOrder != null),
        filterSelections = {
          for (final entry in config.filters.entries)
            entry.key: entry.value.defaultSelection,
          ...filterSelections,
        };

  final SortFilter<T> config;

  final String sortSelectionKey;
  Sorter<T> get sortSelection => config.sorters[sortSelectionKey];
  final SortOrder sortOrder;

  final Map<String, dynamic> filterSelections;

  SortFilterSelection<T> withSortSelection(String selectedKey) {
    return SortFilterSelection(
      config: config,
      sortSelectionKey: selectedKey,
      sortOrder: selectedKey == sortSelectionKey
          ? sortOrder.inverse
          : SortOrder.ascending,
      filterSelections: filterSelections,
    );
  }

  SortFilterSelection<T> withFilterSelection(String key, dynamic selection) {
    return SortFilterSelection(
      config: config,
      sortSelectionKey: sortSelectionKey,
      sortOrder: sortOrder,
      filterSelections: {
        ...filterSelections,
        key: selection,
      },
    );
  }

  SortFilterSelection<T> withFlagsFilterSelection(
    String flagsKey,
    String flag,
    // ignore: avoid_positional_boolean_parameters
    bool selection,
  ) {
    assert(config.filters[flagsKey] is FlagsFilter);

    return withFilterSelection(flagsKey, <String, bool>{
      ...filterSelections[flagsKey],
      flag: selection,
    });
  }

  List<T> apply(List<T> allItems) {
    Iterable<T> items = List<T>.from(allItems);
    for (final filterOption in filterSelections.entries) {
      final filter = config.filters[filterOption.key];
      items = filter.apply(items, filterOption.value);
    }
    return List<T>.from(items)
      ..sort(sortSelection.comparator.withOrder(sortOrder));
  }

  void showSheet({
    @required BuildContext context,
    @required SortFilterChangeCallback<T> callback,
  }) {
    assert(context != null);
    assert(callback != null);

    var currentSelection = this;
    context.showFancyModalBottomSheet(
      // Gives us more vertical space.
      isScrollControlled: true,
      useRootNavigator: true,
      builder: (_) {
        return Padding(
          padding: EdgeInsets.symmetric(horizontal: 16),
          child: StatefulBuilder(
            builder: (_, setState) {
              return SortFilterSelectionWidget(
                selection: currentSelection,
                onSelectionChange: (selection) {
                  setState(() => currentSelection = selection);
                  callback(selection);
                },
              );
            },
          ),
        );
      },
    );
  }
}

class SortFilterSelectionWidget<T> extends StatelessWidget {
  const SortFilterSelectionWidget({
    Key key,
    @required this.selection,
    @required this.onSelectionChange,
  })  : assert(selection != null),
        assert(onSelectionChange != null),
        super(key: key);

  final SortFilterSelection<T> selection;
  SortFilter<T> get config => selection.config;

  final SortFilterChangeCallback<T> onSelectionChange;

  @override
  Widget build(BuildContext context) {
    return Column(
      children: <Widget>[
        _buildSortSection(context),
        for (final filterKey in config.filters.keys)
          _buildFilterSection(context, filterKey),
      ],
    );
  }

  Widget _buildSortSection(BuildContext context) {
    final s = context.s;

    return _Section(
      title: 'Order by',
      child: ChipGroup(
        children: <Widget>[
          for (final sortOption in config.sorters.entries)
            ActionChip(
              avatar: sortOption.key != selection.sortSelectionKey
                  ? null
                  : Icon(selection.sortOrder.icon),
              label: Text(sortOption.value.title(s)),
              onPressed: () => onSelectionChange(
                  selection.withSortSelection(sortOption.key)),
            ),
        ],
      ),
    );
  }

  Widget _buildFilterSection(BuildContext context, String filterKey) {
    final filter = config.filters[filterKey];

    return _Section(
      title: filter.titleGetter(context.s),
      child: filter.buildWidget(
        context,
        selection.filterSelections[filterKey],
        (data) =>
            onSelectionChange(selection.withFilterSelection(filterKey, data)),
      ),
    );
  }
}

class _Section extends StatelessWidget {
  const _Section({Key key, @required this.title, @required this.child})
      : assert(title != null),
        assert(child != null),
        super(key: key);

  final String title;
  final Widget child;

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: EdgeInsets.symmetric(vertical: 8),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: <Widget>[
          Text(title.toUpperCase(), style: context.textTheme.overline),
          SizedBox(height: 4),
          child,
        ],
      ),
    );
  }
}

class SortFilterIconButton extends StatelessWidget {
  const SortFilterIconButton(this.showSortFilterSheet)
      : assert(showSortFilterSheet != null);

  final VoidCallback showSortFilterSheet;

  @override
  Widget build(BuildContext context) {
    return IconButton(
      icon: Icon(Icons.sort),
      tooltip: context.s.app_sortFilterIconButton,
      onPressed: showSortFilterSheet,
    );
  }
}

class SortFilterEmptyState extends StatelessWidget {
  const SortFilterEmptyState(
    this.showSortFilterSheet, {
    @required this.text,
    this.asset = 'default',
  })  : assert(showSortFilterSheet != null),
        assert(text != null),
        assert(asset != null);

  final VoidCallback showSortFilterSheet;
  final String text;
  final String asset;

  @override
  Widget build(BuildContext context) {
    return EmptyStatePage(
      text: text,
      asset: asset,
      actions: <Widget>[
        SecondaryButton(
          onPressed: showSortFilterSheet,
          child: Text(context.s.app_sortFilterEmptyState_editFilters),
        ),
      ],
    );
  }
}

abstract class SortFilterWidget<T> extends StatefulWidget {
  const SortFilterWidget(this.initialSortFilterSelection, {Key key})
      : assert(initialSortFilterSelection != null),
        super(key: key);

  final SortFilterSelection<T> initialSortFilterSelection;
}

typedef FilterSetter = void Function(String key, dynamic selection);
typedef FlagFilterSetter = void Function(String key, bool value);

mixin SortFilterStateMixin<W extends SortFilterWidget<T>, T> on State<W> {
  SortFilterSelection<T> sortFilterSelection;

  @override
  void initState() {
    super.initState();

    sortFilterSelection = widget.initialSortFilterSelection;
  }

  void showSortFilterSheet() {
    sortFilterSelection.showSheet(
      context: context,
      callback: updateSortFilterSelection,
    );
  }

  void updateSortFilterSelection(SortFilterSelection<T> selection) {
    setState(() => sortFilterSelection = selection);
  }

  void setFilter(String key, dynamic selection) {
    updateSortFilterSelection(
        sortFilterSelection.withFilterSelection(key, selection));
  }

  // ignore: avoid_positional_boolean_parameters
  void setFlagFilter(String key, bool value) {
    updateSortFilterSelection(
        sortFilterSelection.withFlagsFilterSelection('more', key, value));
  }
}

typedef SortFilterWidgetBuilder<E extends Entity<E>> = Widget Function(
  BuildContext context,
  E entity,
  FilterSetter filterSetter,
  FlagFilterSetter flagFilterSetter,
);
typedef SortFilterAppBarBuilder = Widget Function(
  BuildContext context,
  VoidCallback showSortFilterSheet,
);

class SortFilterPage<E extends Entity<E>> extends SortFilterWidget<E> {
  SortFilterPage({
    @required this.config,
    SortFilterSelection<E> initialSelection,
    @required this.collection,
    @required this.appBarBuilder,
    @required this.emptyStateTextGetter,
    this.emptyStateAsset = 'default',
    @required this.filteredEmptyStateTextGetter,
    @required this.builder,
  })  : assert(config != null),
        assert(collection != null),
        assert(appBarBuilder != null),
        assert(emptyStateTextGetter != null),
        assert(emptyStateAsset != null),
        assert(filteredEmptyStateTextGetter != null),
        assert(builder != null),
        super(initialSelection ?? config.defaultSelection);

  final SortFilter<E> config;
  final Collection<E> collection;
  final SortFilterAppBarBuilder appBarBuilder;
  final L10nStringGetter emptyStateTextGetter;
  final String emptyStateAsset;
  final L10nStringGetter filteredEmptyStateTextGetter;
  final SortFilterWidgetBuilder<E> builder;

  @override
  _SortFilterPageState<E> createState() => _SortFilterPageState<E>();
}

class _SortFilterPageState<E extends Entity<E>> extends State<SortFilterPage<E>>
    with SortFilterStateMixin<SortFilterPage<E>, E> {
  @override
  Widget build(BuildContext context) {
    final s = context.s;

    return Scaffold(
      body: CollectionBuilder.populated<E>(
        collection: widget.collection,
        builder: handleLoadingErrorRefreshEmptyFilter(
          appBar: widget.appBarBuilder(context, showSortFilterSheet),
          emptyStateBuilder: (_) =>
              EmptyStatePage(text: widget.emptyStateTextGetter(s)),
          sortFilterSelection: sortFilterSelection,
          filteredEmptyStateBuilder: (_) => SortFilterEmptyState(
            showSortFilterSheet,
            text: widget.filteredEmptyStateTextGetter(s),
            asset: widget.emptyStateAsset,
          ),
          builder: (_, entities, __) {
            return CustomScrollView(
              slivers: <Widget>[
                SliverList(
                  delegate: SliverChildBuilderDelegate(
                    (context, index) => widget.builder(
                      context,
                      entities[index],
                      setFilter,
                      setFlagFilter,
                    ),
                    childCount: entities.length,
                  ),
                ),
              ],
            );
          },
        ),
      ),
    );
  }
}
